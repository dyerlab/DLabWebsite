{
  "hash": "2b140fe3d59d20880c66d65f30a15dca",
  "result": {
    "markdown": "---\ntitle: \"Unix Basics\"\ndescription: |\n  A short description of the post.\nauthor:\n  - name: Rodney Dyer\n    url: https://dyerlab.org\n    affiliation: Center for Environmental Studies\n    affiliation_url: https://ces.vcu.edu\n    orcid_id: 0000-0003-4707-3453\ndate: 2013-10-10\noutput:\n  distill::distill_article:\n    self_contained: false\n---\n\n\n\n\n\nThis covers some basic unix commands so that you can log into a machine and move around in it with ease.  It is by no means comprehensive.\n\n# Logging In\n\nTo log into a machine you must use SSH.  This is a secure shell and is encrypted on both ends so that others cannot snoop on your passwords or activities.   If you are a windows person (shudder), you will have to use a GUI application to log into the server.  Download one and install it.  The server we will be using in this exercise is:\n\n###### chesapeake.envs.vcu.edu\n\nand can also be referenced by the raw IP address as:\n\n###### 128.172.178.27\n\nBoth of these addresses are the same.  You will need both a user name and password on the server before you can log into it.\n\nIf you are outside VCU network, you will have to log into our VPN (see vcu.edu and search for webvpn if you do not know how to do this).  On a mac/unix/linux box, you can use the terminal application to log into the server as:\n\n###### ssh chesapeake.envs.vcu.edu\n\nor with the raw IP address.  Note: if you have a user name that is different on your local machine than it is on the server, you need to specify that in the ssh call as:\n\n###### ssh server\\_user\\_id@chesapeake.envs.vcu.edu\n\nOnce you log into the remote server you will be greeted with a prompt from which you will be able to interact with the computer directly (e.g., no need for gui-pointy-clicky stuff).\n\n# Bash\n\nWhen you are logged into the server, you are actually working in an interactive programming environment.  By default, the dyerlab servers run the Bash Shell.  This is a command line interface that has the ability to do quite a few things that reduce the amount of tedium in your computational life.  The entire philosophy of unix is to provide an environment where:\n\n  1. There is a strict partition between the stuff that you do in your own account and the stuff others do.  Security at the OS level is priority number one and as such has a fairly strict set of requirements for what you as a user can see and do.  This is good.\n  2. Things work well together.  Programs are small.  There is no monolithic program that tries to do everything (except emacs but that is a flamewar of a different type).  Programs do one type of task and do not try to multitask.  This is very good because we have evolved an ecosystem of programs that are very efficient.\n  3. It is assumed that unix programs read and write text files, not binary files.  It goes against the philosophy of the OS for a program to sequester its data into formats that are unreachable by other programs.  If a program does this then it is no longer a citizen of the unix program community and as such has cut itself off from the breadth of opportunities that such an interaction entails.  This is a very very good thing because you as a user can build complicated workflows in the environment that achieve things that would take much longer in the normal clickity-clickity mouse world we typically inhabit.\n\n# Basic Commands\n\nTo move around a unix box on a server you are not in front of, you must do it from the command line.  You will always be logged into your ‘home’ account.  This is literally at the location in the file system /home/your\\_user\\_name. Everyone has their own home directory and you cannot see what is in other peoples home directories unless they do some rather severe hacks (violating #1 above).  However, there are places you can put stuff to share materials between users, it is just not within the home directory.  Here is an overview of some basic commands. You can always find out where you are by typing:\n\n**** ****\n\n<table>\n  <tr>\n    <td>\n      <b>Program</b>\n    </td>\n    \n    <td>\n      <b>Description</b>\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      pwd\n    </td>\n    \n    <td>\n      Prints out the current directory you are in.\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      ls\n    </td>\n    \n    <td>\n      Lists the files and folders in that directory (see ls -l for a long listing)\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      cd\n    </td>\n    \n    <td>\n      Change to your home directory\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      cd ..\n    </td>\n    \n    <td>\n      Changes to directory that is the immediate parent of the current one\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      cd folder\n    </td>\n    \n    <td>\n      Changes the directory to ‘folder’\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      exit\n    </td>\n    \n    <td>\n      Logs you out of the computer\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      chmod\n    </td>\n    \n    <td>\n      Changes the permission/privileges for files.\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      echo\n    </td>\n    \n    <td>\n      Prints out variables/content to the shell output\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      cat\n    </td>\n    \n    <td>\n      Concatenates text to the terminal output\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      head\n    </td>\n    \n    <td>\n      Prints out the top lines of a file\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      wc\n    </td>\n    \n    <td>\n      Counts words (default) or lines (-l) in a file\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      grep\n    </td>\n    \n    <td>\n      Gets a regular expression (e.g., used for text searching)\n    </td>\n  </tr>\n</table>\n\nAlmost all programs (pwd, ls, cd, etc.) have a manual associated with them.  This is because there are often many options to modify the behavior of the output.  You can get to the manual for any program by:\n\n###### man prog\n\nAll manual entries have the same format and go through all the options available.\n\n# Editing Files\n\nThere is a plethora of editors available to the unix user.  Perhaps the easiest one on the servers you’ll be using is nano.  This is a simple editor that allows you to open, change, and save text files.  Given that this is a command-line environment, the menu-like options are available via keyboard combinations indicated at the bottom of the screen.  In most unix environments the symbol ‘^’ denotes the control key (e.g., ^-Q would be holding down the control key and typing Q), and ‘M’ denotes the key labelled ‘alt’ (the modifier key).  In nano these combinations act as the menu functionality.\n\nTo start an editing session type:\n\n###### nano\n\nand it will make a new file.  If you have an existing file, you can edit it as:\n\n###### nano myfile.fasta\n\nfor example and it will open it up and start you on an editing session.\n\n# Putting and Getting Files\n\nTo move documents from your computer to a remote server, we use the SSH Copy command ‘scp’.  This is built into the ssh software itself.\n\n###### scp file remoteserver:~/\n\nThe last part, ‘:~/’ is required as it tells scp that the remoteserver is a server and you want the file to go into your home directory ‘~/’\n\n###### scp myremoteserver:~/thefile .\n\nThis will pull a file from the remote server to your current directory.  Again notice that the period is there, a period in the options to a program specifically means ‘this place in the directory heirarchy.’\n\nIf you are using windows, there is a GUI drag and drop interface with your SSH client.\n\n# Running a Command Line Program\n\nOn a server all programs are run from the command line.  You have already seen that you can run a program by typing its name and hitting return.  The only reason this works is because there are executable binary files located in specific directories on the machine.  These directories are all called ‘bin’ and they are located in parts of the folder heirarchy dictating who can access them.  If you type at the command prompt:\n\n###### echo $PATH\n\nit will return all the bin files that you are, by default, able to search for programs.  The program echo prints out the value of a variable and all Bash Shell variables are indicated by a dollar sign (and by convention are typed in all upcase).\n\nIf a program is not in a ‘bin’ folder you access it will not run when you simply type its name.  What you have to do is to tell the Bash Shell the location of the program specifically, even if it is in the same directory as you are.\n\nThere is one more requirement to execute a program.  The program must be labelled as something that can be executed!  In unix, scripts such as Bash Scripts, perl, python, lua, and many other languages can be used to make programs but these programs are just text files containing the instructions necessary to perform a task.  To designate a program as a specific one that can be executed (if its contents actually can do something) you need to set the executable bit on the file by changing the mode of the file.  This is done using chmod and telling it to add executable privileges.\n\n###### chmod +x program_file\n\nMany things have executable privileges, try a ls -l and look at the far left column to see the privileges, the last digit is either x or &#8211; indicating executable status or not (n.b., folders are executable, if you turn it off you will not be able to change directory into that folder).\n\n# Redirecting Output\n\nAs mentioned above, programs are small and do specialized things but can work together in ways that are quite dynamic.  This is done by redirecting output.  Here are some examples.  In the directory /usr/share/velvet\\_1.2.10/data, there are several example fasta files that come with velvet.  Copy the test\\_reference.fa file to your directory as:\n\n###### cp /usr/share/velvet\\_1.2.10/data/test\\_reads.fa .\n\nYou should be able to see this file in your directory (via ls).  Lets count how many lines are in that file.  I see the following output (yours will be a bit different because you are not in my home directory (all the stuff to the left of the $ is not typed and is part of the bash prompt).\n\n###### rodney@chesapeake ~ $ wc -l test_reads.fa\n\n###### 285716 test_reads.fa\n\nSo this file has 285,716 lines in it.  Lets now look at the first few lines:\n\n###### >SEQUENCE\\_0\\_length_35\n\n###### GGATATAGGGCCAACCCAACTCAACGGCCTGTCTT\n\n###### >SEQUENCE\\_1\\_length_35\n\n###### CGACGAATGACAGGTCACGAATTTGGCGGGGATTA\n\n###### >SEQUENCE\\_2\\_length_35\n\n###### CCAAATAGGTCCTTACATCATGAGACGGGCCAAAT\n\n###### >SEQUENCE\\_3\\_length_35\n\n###### CGAGATGTATACCTCTAACACTGTGTTCCAAGTAC\n\n###### >SEQUENCE\\_4\\_length_35\n\n###### AAGCTCCCGCAATGGATCTTGTGACGGGCTGCTCG\n\nThis output is dumped to the terminal.  To redirect this output to another place, say a file, we use the redirect operator ‘>’ otherwise known as the greater than sign.\n\n###### rodney@chesapeake ~ $ head test_reads.fa > firstfew.fa\n\n###### rodney@chesapeake ~ $ wc -l firstfew.fa\n\n###### 10 firstfew.fa\n\n# Piping Between Programs\n\nHooking together programs is the next step and it is called piping.  It is accomplished by hooking together the output of one program with the input of another using the pipe character ‘|’ (the vertical line on the slash key on US english keyboards).  Lets say I wanted to search for a particular sequence in the test_reads.fa file. I’ll use GATACA because it was a good movie.  I use the grep command to find it by passing first what I am looking for and then the file I am looking for it in.  I will then pipe this through the wc  program to see how many lines have that sequence of nucleotides within it.\n\n###### rodney@chesapeake ~ $ grep GATACA test_reads.fa  | wc -l\n\n###### 790\n\nSo there are almost 800 reads with that sequence in it.  We can continue to combine commands together beyond just these two.  See if you can figure out what these commands do:\n\n###### rodney@chesapeake ~ $ cat test_reads.fa | sort | head -100 > sortedfirstfew.fa\n\n###### rodney@chesapeake ~ $ head sortedfirstfew.fa\n\n###### AAAAAAAACGGGCTTATAGACCATGCAGGCTTCAT\n\n###### AAAAAAACACTATACAGCCAGAGTTCCTTCTTCTT\n\n###### AAAAAAACCCTTCTGTGTTTGATCTACCTACTATA\n\n###### AAAAAAACGGGCTTATAGACCATGCAGGCTTCATG\n\n###### AAAAAAACGTAAGGAGCGTTTATGCCAAACGAAGA\n\n###### AAAAAAAGGCTCGTGACTGTCATCATCGAGACGCC\n\n###### AAAAAAAGTGGGGTTCAAACACTCTATCCATGAAG\n\n###### AAAAAAATTGACTGTTAATGGCAATTTCAAGTTAT\n\n###### AAAAAACAGCGAACCAGATCTTATTTTGCTTCTAC\n\n###### AAAAAACATGACAACGAGAGCAACCCGGGCATTTG\n\n# Screen\n\nOK, so when working on long-running programs, there is the need to be able to log in and out of a session without the various things you have running stopping each time.  When you log into a unix machine, you start a ‘session’ and you can log in many times using the same user ID.  When you log out, every process (running program) is purged from the memory and thus lost.  So unless you plan on being logged into a terminal until a long running process is done running (some may take months), a better solution is needed.  This is where a program called ‘screen’ comes in handy.\n\nScreen is a program that is run after you log into the server.  What this does is to then make a ‘virtual session’ (or many of them) that you can attach and detach your terminal session to.  You start screen by typing:\n\n###### screen\n\nand then a read the verbage and continue (via space bar or hitting return). After that it will look like your normal terminal session and you’ll be able to do whatever you want to do just like before.  Screen is running in the background\n\nSo lets say you start a long running process like:\n\n###### ./VelvetOptimiser.pl -s 16 -e 31 -f &#8220;-short -raw ~/data/pedima/pedimaSNPs.fasta&#8221;\n\nThis can take a while to run.  Now that you are already within a screen session, you can run it and then detach your terminal from that screen session. After you detach, the program will continue running just as before and you can re-attach at a later time to check on progress.\n\nHere are the commands for listing, attaching, and detaching from screen sessions (n.b., they all start with CTRL+a followed by another letter.\n\n<table>\n  <tr>\n    <td>\n      Keys\n    </td>\n    \n    <td>\n      Description\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a c\n    </td>\n    \n    <td>\n      Creates a new shell window\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a k\n    </td>\n    \n    <td>\n      Kills the current window\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a w\n    </td>\n    \n    <td>\n      Lists all windows (the current session is marked with an ‘*’)\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a d\n    </td>\n    \n    <td>\n      Detach from current session\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a D\n    </td>\n    \n    <td>\n      Detach from current session and close the shell as well\n    </td>\n  </tr>\n  \n  <tr>\n    <td>\n      CTRL+a 0-9\n    </td>\n    \n    <td>\n      Go to session 0, 1, … 9\n    </td>\n  </tr>\n</table>\n\nAfter you detach (CTRL+a d) you can exit the server and when you come back, you can reattach as:\n\n###### screen -r\n\nif you only have one screen session going, otherwise you can just start screen, list the open sessions, and then come back at that time.\n\n# Velvet\n\nLink to UMissouri\n\n<http://umbc.rnet.missouri.edu/resources/How2RunVELVETonClark.html>\n\nFrom NCBI: A basic protocol\n\n<http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2952100/>\n \n \n \n",
    "supporting": [
      "unix-basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}